Liferay.Loader.define("@crud-project$tanstack/virtual-core@3.0.0-beta.13/build/umd/index.production", ['module', 'exports', 'require'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    function _objectWithoutProperties(obj, keys) {
      var target = {};

      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }

      return target;
    }

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    /**
     * virtual-core
     *
     * Copyright (c) TanStack
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    !function (e, t) {
      "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).VirtualCore = {});
    }(this, function (e) {
      "use strict";
      var t,
          s = ["bottom", "height", "left", "right", "top", "width"],
          n = new Map(),
          o = function e() {
        var o = [];n.forEach(function (e, t) {
          var n,
              i,
              l = t.getBoundingClientRect();n = l, i = e.rect, void 0 === n && (n = {}), void 0 === i && (i = {}), s.some(function (e) {
            return n[e] !== i[e];
          }) && (e.rect = l, o.push(e));
        }), o.forEach(function (e) {
          e.callbacks.forEach(function (t) {
            return t(e.rect);
          });
        }), t = window.requestAnimationFrame(e);
      };function i(e, t, s) {
        let n,
            o = [];return () => {
          let i;s.key && null != s.debug && s.debug() && (i = Date.now());const l = e();if (!(l.length !== o.length || l.some((e, t) => o[t] !== e))) return n;let r;if (o = l, s.key && null != s.debug && s.debug() && (r = Date.now()), n = t(...l), null == s || null == s.onChange || s.onChange(n), s.key && null != s.debug && s.debug()) {
            const e = Math.round(100 * (Date.now() - i)) / 100,
                  t = Math.round(100 * (Date.now() - r)) / 100,
                  o = (e, t) => {
              for (e = String(e); e.length < t;) e = " " + e;return e;
            };console.info("%câ± " + o(t, 5) + " /" + o(e, 5) + " ms", "\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(" + Math.max(0, Math.min(120 - 120 * (t / 16), 120)) + "deg 100% 31%);", null == s ? void 0 : s.key);
          }return n;
        };
      }const l = e => e,
            r = e => {
        const t = Math.max(e.startIndex - e.overscan, 0),
              s = Math.min(e.endIndex + e.overscan, e.count - 1),
              n = [];for (let e = t; e <= s; e++) n.push(e);return n;
      },
            a = (e, t) => {
        let s = { height: -1, width: -1 };return n => {
          (e.options.horizontal ? n.width !== s.width : n.height !== s.height) && t(n), s = n;
        };
      },
            h = { element: ["scrollLeft", "scrollTop"], window: ["scrollX", "scrollY"] },
            c = e => (t, s) => {
        if (!t.scrollElement) return;const n = h[e][0],
              o = h[e][1];let i = t.scrollElement[n],
            l = t.scrollElement[o];const r = () => {
          s(t.scrollElement[t.options.horizontal ? n : o]);
        };r();const a = e => {
          const s = e.currentTarget,
                a = s[n],
                h = s[o];(t.options.horizontal ? i - a : l - h) && r(), i = a, l = h;
        };return t.scrollElement.addEventListener("scroll", a, { capture: !1, passive: !0 }), () => {
          t.scrollElement.removeEventListener("scroll", a);
        };
      },
            u = c("element"),
            d = c("window"),
            f = (e, t) => e.getBoundingClientRect()[t.options.horizontal ? "width" : "height"];e.Virtualizer = class {
        constructor(e) {
          var t = this;this.unsubs = [], this.scrollElement = null, this.measurementsCache = [], this.itemMeasurementsCache = {}, this.pendingMeasuredCacheIndexes = [], this.measureElementCache = {}, this.setOptions = e => {
            Object.entries(e).forEach(t => {
              let [s, n] = t;void 0 === n && delete e[s];
            }), this.options = _extends({ debug: !1, initialOffset: 0, overscan: 1, paddingStart: 0, paddingEnd: 0, scrollPaddingStart: 0, scrollPaddingEnd: 0, horizontal: !1, getItemKey: l, rangeExtractor: r, enableSmoothScroll: !0, onChange: () => {}, measureElement: f, initialRect: { width: 0, height: 0 } }, e);
          }, this.notify = () => {
            var e, t;null == (e = (t = this.options).onChange) || e.call(t, this);
          }, this.cleanup = () => {
            this.unsubs.filter(Boolean).forEach(e => e()), this.unsubs = [], this.scrollElement = null;
          }, this._didMount = () => () => {
            this.cleanup();
          }, this._willUpdate = () => {
            const e = this.options.getScrollElement();this.scrollElement !== e && (this.cleanup(), this.scrollElement = e, this.unsubs.push(this.options.observeElementRect(this, e => {
              this.scrollRect = e, this.notify();
            })), this.unsubs.push(this.options.observeElementOffset(this, e => {
              this.scrollOffset = e, this.notify();
            })));
          }, this.getSize = () => this.scrollRect[this.options.horizontal ? "width" : "height"], this.getMeasurements = i(() => [this.options.count, this.options.paddingStart, this.options.getItemKey, this.itemMeasurementsCache], (e, t, s, n) => {
            const o = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;this.pendingMeasuredCacheIndexes = [];const i = this.measurementsCache.slice(0, o);for (let l = o; l < e; l++) {
              const e = s(l),
                    o = n[e],
                    r = i[l - 1] ? i[l - 1].end : t,
                    a = "number" == typeof o ? o : this.options.estimateSize(l);i[l] = { index: l, start: r, size: a, end: r + a, key: e };
            }return this.measurementsCache = i, i;
          }, { key: !1, debug: () => this.options.debug }), this.calculateRange = i(() => [this.getMeasurements(), this.getSize(), this.scrollOffset], (e, t, s) => function (e) {
            let { measurements: t, outerSize: s, scrollOffset: n } = e;const o = t.length - 1,
                  i = ((e, t, s, n) => {
              for (; e <= t;) {
                const o = (e + t) / 2 | 0,
                      i = s(o);if (i < n) e = o + 1;else {
                  if (!(i > n)) return o;t = o - 1;
                }
              }return e > 0 ? e - 1 : 0;
            })(0, o, e => t[e].start, n);let l = i;for (; l < o && t[l].end < n + s;) l++;return { startIndex: i, endIndex: l };
          }({ measurements: e, outerSize: t, scrollOffset: s }), { key: !1, debug: () => this.options.debug }), this.getIndexes = i(() => [this.options.rangeExtractor, this.calculateRange(), this.options.overscan, this.options.count], (e, t, s, n) => e(_extends({}, t, { overscan: s, count: n })), { key: !1 }), this.getVirtualItems = i(() => [this.getIndexes(), this.getMeasurements(), this.options.measureElement], (e, t, s) => {
            const n = e => t => {
              var n;const o = this.measurementsCache[e];if (!t) return;const i = s(t, this),
                    l = null != (n = this.itemMeasurementsCache[o.key]) ? n : o.size;i !== l && (o.start < this.scrollOffset && (this.destinationOffset || this._scrollToOffset(this.scrollOffset + (i - l), !1)), this.pendingMeasuredCacheIndexes.push(e), this.itemMeasurementsCache = _extends({}, this.itemMeasurementsCache, { [o.key]: i }), this.notify());
            },
                  o = [],
                  i = {};for (let s = 0, r = e.length; s < r; s++) {
              var l;const r = e[s],
                    a = _extends({}, t[r], { measureElement: i[r] = null != (l = this.measureElementCache[r]) ? l : n(r) });o.push(a);
            }return this.measureElementCache = i, o;
          }, { key: !1 }), this.scrollToOffset = function (e, s) {
            let { align: n } = void 0 === s ? { align: "start" } : s;const o = () => {
              const s = t.scrollOffset,
                    o = t.getSize();"auto" === n && (n = e <= s ? "start" : e >= s + o ? "end" : "start"), "start" === n ? t._scrollToOffset(e, !0) : "end" === n ? t._scrollToOffset(e - o, !0) : "center" === n && t._scrollToOffset(e - o / 2, !0);
            };o(), requestAnimationFrame(() => {
              o();
            });
          }, this.scrollToIndex = function (e, s) {
            let _ref = void 0 === s ? { align: "auto" } : s,
                { align: n } = _ref,
                o = _objectWithoutProperties(_ref, ["align"]);const i = t.getMeasurements(),
                  l = t.scrollOffset,
                  r = t.getSize(),
                  { count: a } = t.options,
                  h = i[Math.max(0, Math.min(e, a - 1))];if (!h) return;if ("auto" === n) if (h.end >= l + r - t.options.scrollPaddingEnd) n = "end";else {
              if (!(h.start <= l + t.options.scrollPaddingStart)) return;n = "start";
            }const c = "end" === n ? h.end + t.options.scrollPaddingEnd : h.start - t.options.scrollPaddingStart;t.scrollToOffset(c, _extends({ align: n }, o));
          }, this.getTotalSize = () => {
            var e;return ((null == (e = this.getMeasurements()[this.options.count - 1]) ? void 0 : e.end) || this.options.paddingStart) + this.options.paddingEnd;
          }, this._scrollToOffset = (e, t) => {
            let s;clearTimeout(this.scrollCheckFrame), this.destinationOffset = e, this.options.scrollToFn(e, this.options.enableSmoothScroll && t, this);const n = () => {
              let e = this.scrollOffset;this.scrollCheckFrame = s = setTimeout(() => {
                this.scrollCheckFrame === s && (this.scrollOffset !== e ? (e = this.scrollOffset, n()) : this.destinationOffset = void 0);
              }, 100);
            };n();
          }, this.measure = () => {
            this.itemMeasurementsCache = {}, this.notify();
          }, this.setOptions(e), this.scrollRect = this.options.initialRect, this.scrollOffset = this.options.initialOffset;
        }
      }, e.defaultKeyExtractor = l, e.defaultRangeExtractor = r, e.elementScroll = (e, t, s) => {
        var n;null == (n = s.scrollElement) || n.scrollTo({ [s.options.horizontal ? "left" : "top"]: e, behavior: t ? "smooth" : void 0 });
      }, e.measureElement = f, e.memo = i, e.observeElementOffset = u, e.observeElementRect = (e, s) => {
        const i = a(e, s),
              l = function (e, s) {
          return { observe: function () {
              var t = 0 === n.size;n.has(e) ? n.get(e).callbacks.push(s) : n.set(e, { rect: void 0, hasRectChanged: !1, callbacks: [s] }), t && o();
            }, unobserve: function () {
              var o = n.get(e);if (o) {
                var i = o.callbacks.indexOf(s);i >= 0 && o.callbacks.splice(i, 1), o.callbacks.length || n.delete(e), n.size || cancelAnimationFrame(t);
              }
            } };
        }(e.scrollElement, e => {
          i(e);
        });if (e.scrollElement) return i(e.scrollElement.getBoundingClientRect()), l.observe(), () => {
          l.unobserve();
        };
      }, e.observeWindowOffset = d, e.observeWindowRect = (e, t) => {
        const s = a(e, t),
              n = () => s({ width: e.scrollElement.innerWidth, height: e.scrollElement.innerHeight });if (e.scrollElement) return n(), e.scrollElement.addEventListener("resize", n, { capture: !1, passive: !0 }), () => {
          e.scrollElement.removeEventListener("resize", n);
        };
      }, e.windowScroll = (e, t, s) => {
        var n;null == (n = s.scrollElement) || n.scrollTo({ [s.options.horizontal ? "left" : "top"]: e, behavior: t ? "smooth" : void 0 });
      }, Object.defineProperty(e, "__esModule", { value: !0 });
    });
    //# sourceMappingURL=index.production.js.map
  }
});
//# sourceMappingURL=index.production.js.map